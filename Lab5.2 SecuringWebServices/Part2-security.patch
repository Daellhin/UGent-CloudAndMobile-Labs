diff --git a/build.gradle.kts b/build.gradle.kts
index 9478fad..d64f8d0 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -30,6 +30,9 @@ dependencies {
     val influx_version: String by project
     val logback_version: String by project
     val graphql_kt_version: String by project
+    val bcrypt_version: String by project
+    val exposed_version: String by project
+    val mariadb_version: String by project
 
     // basic architecture dependencies
     implementation("com.influxdb:influxdb-client-kotlin:$influx_version")
@@ -48,6 +51,14 @@ dependencies {
     implementation("io.ktor:ktor-client-core:$ktor_version")
     implementation("io.ktor:ktor-client-cio:$ktor_version")
     implementation("io.ktor:ktor-client-content-negotiation:$ktor_version")
+    // egress session/auth dependencies
+    implementation("io.ktor:ktor-server-auth:$ktor_version")
+    implementation("io.ktor:ktor-server-auth-jwt:$ktor_version")
+    // egress user management dependencies
+    implementation("at.favre.lib:bcrypt:$bcrypt_version")
+    implementation("org.jetbrains.exposed:exposed-core:$exposed_version")
+    implementation("org.jetbrains.exposed:exposed-jdbc:$exposed_version")
+    implementation("org.mariadb.jdbc:mariadb-java-client:$mariadb_version")
     // test-only dependencies
     testImplementation(kotlin("test"))
     testImplementation("io.ktor:ktor-server-test-host:$ktor_version")
diff --git a/gradle.properties b/gradle.properties
index f7d3ad3..958b1fe 100644
--- a/gradle.properties
+++ b/gradle.properties
@@ -6,4 +6,7 @@ kt_datetime_version=0.5.0
 kt_serialization_version=1.6.2
 influx_version=6.12.0
 logback_version=1.4.7
-graphql_kt_version=7.0.2
\ No newline at end of file
+graphql_kt_version=7.0.2
+bcrypt_version=0.10.2
+exposed_version=0.49.0
+mariadb_version=3.3.3
diff --git a/src/main/kotlin/server/modules/graphql/Module.kt b/src/main/kotlin/server/modules/graphql/Module.kt
index 0988159..b3713a1 100644
--- a/src/main/kotlin/server/modules/graphql/Module.kt
+++ b/src/main/kotlin/server/modules/graphql/Module.kt
@@ -1,5 +1,6 @@
 package be.ugent.idlab.predict.ocmt.egress.server.modules.graphql
 
+import be.ugent.idlab.predict.ocmt.egress.server.modules.security.authenticate
 import com.expediagroup.graphql.server.ktor.GraphQL
 import com.expediagroup.graphql.server.ktor.graphQLGetRoute
 import io.ktor.server.application.*
@@ -18,6 +19,8 @@ fun Application.module() {
         }
     }
     routing {
-        graphQLGetRoute("/graphql")
+        authenticate {
+            graphQLGetRoute("/graphql")
+        }
     }
 }
diff --git a/src/main/kotlin/server/modules/rest/Module.kt b/src/main/kotlin/server/modules/rest/Module.kt
index 844126a..a45e9ea 100644
--- a/src/main/kotlin/server/modules/rest/Module.kt
+++ b/src/main/kotlin/server/modules/rest/Module.kt
@@ -1,5 +1,6 @@
 package be.ugent.idlab.predict.ocmt.egress.server.modules.rest
 
+import be.ugent.idlab.predict.ocmt.egress.server.modules.security.authenticate
 import io.ktor.serialization.kotlinx.json.*
 import io.ktor.server.application.*
 import io.ktor.server.plugins.contentnegotiation.*
@@ -8,17 +9,19 @@ import kotlinx.serialization.json.Json
 
 fun Application.module() {
     routing {
-        route("/rest") {
-            install(ContentNegotiation) {
-                json(Json {
-                    prettyPrint = true
-                })
+        authenticate {
+            route("/rest") {
+                install(ContentNegotiation) {
+                    json(Json {
+                        prettyPrint = true
+                    })
+                }
+                sources()
+                counts()
+                ids()
+                attendance()
+                forecast()
             }
-            sources()
-            counts()
-            ids()
-            attendance()
-            forecast()
         }
     }
 }
diff --git a/src/main/kotlin/server/modules/security/Auth.kt b/src/main/kotlin/server/modules/security/Auth.kt
new file mode 100644
index 0000000..0247a3b
--- /dev/null
+++ b/src/main/kotlin/server/modules/security/Auth.kt
@@ -0,0 +1,50 @@
+package be.ugent.idlab.predict.ocmt.egress.server.modules.security
+
+import io.ktor.serialization.kotlinx.json.*
+import io.ktor.server.application.*
+import io.ktor.server.auth.*
+import io.ktor.server.auth.jwt.*
+import io.ktor.server.plugins.contentnegotiation.*
+import io.ktor.server.response.*
+import io.ktor.server.routing.*
+
+fun Application.configure() {
+    configureAuth()
+    configureSessionEndpoints()
+    install(BackoffPlugin)
+}
+
+private fun Application.configureAuth() {
+    install(Authentication) {
+        jwt("auth-jwt") {
+            TODO("""
+                Configure to accept tokens generated by `SessionManager`, validating the username & challenging 
+                unauthorized requests
+            """)
+        }
+    }
+}
+
+private fun Application.configureSessionEndpoints() {
+    routing {
+        install(ContentNegotiation) {
+            json()
+        }
+        post("/register") {
+            TODO("Use `SessionManager` to create a new user account, which potentially fails")
+        }
+        post("/login") {
+            TODO("Use `SessionManager` to authenticate the incoming credentials")
+        }
+        authenticate {
+            get("me") {
+                val name = call.principal<JWTPrincipal>()!!.payload.getClaim("username")!!.asString()
+                call.respond("Hi, $name")
+            }
+        }
+    }
+}
+
+fun Routing.authenticate(block: Route.() -> Unit) {
+    authenticate("auth-jwt", build = block)
+}
diff --git a/src/main/kotlin/server/modules/security/Backoff.kt b/src/main/kotlin/server/modules/security/Backoff.kt
new file mode 100644
index 0000000..eb85824
--- /dev/null
+++ b/src/main/kotlin/server/modules/security/Backoff.kt
@@ -0,0 +1,8 @@
+package be.ugent.idlab.predict.ocmt.egress.server.modules.security
+
+import io.ktor.server.application.*
+
+val BackoffPlugin = createApplicationPlugin("BackoffPlugin") {
+    // TODO: observe response codes in this plugin, using `RateLimiter` to rate limit incoming calls from hosts
+    //  repeatedly making unauthorized or otherwise erroneous requests
+}
diff --git a/src/main/kotlin/services/auth/RateLimiter.kt b/src/main/kotlin/services/auth/RateLimiter.kt
new file mode 100644
index 0000000..12eb70c
--- /dev/null
+++ b/src/main/kotlin/services/auth/RateLimiter.kt
@@ -0,0 +1,77 @@
+package be.ugent.idlab.predict.ocmt.egress.services.auth
+
+import be.ugent.idlab.predict.ocmt.egress.services.resolve
+import io.ktor.server.application.*
+import io.ktor.server.plugins.*
+import io.ktor.util.logging.*
+import kotlinx.datetime.Clock
+import kotlinx.datetime.Instant
+import java.util.*
+import kotlin.time.Duration.Companion.milliseconds
+
+object RateLimiter {
+
+    private val LOGGER = KtorSimpleLogger("services.RateLimiter")
+
+    private val properties = this::class.java
+        .classLoader
+        .getResourceAsStream("auth.properties")
+        .use { Properties().apply { load(it) } }
+
+    // behaviour config
+    private val timeout = properties.resolve("rl.timeout").toInt().milliseconds
+    private val period = properties.resolve("rl.period").toInt().milliseconds
+    private val frequency = properties.resolve("rl.frequency").toInt()
+
+    // recent bad calls not yet banned
+    private val pending = mutableMapOf<String, SortedSet<Instant>>()
+    // hosts currently banned, paired with their ban end
+    private val banned = mutableMapOf<String, Instant>()
+
+    fun isRateLimited(call: ApplicationCall): Boolean {
+        update()
+        // checking if host is in there
+        return (call.host in banned)
+            .also { banned -> if (banned) LOGGER.info("Requester ${call.host} is currently banned") }
+    }
+
+    fun onBadCallMade(call: ApplicationCall) {
+        update()
+        val host = call.host
+        if (host in banned) {
+            // increasing their timeout by re-banning them
+            ban(host)
+            return
+        }
+        val history = pending.getOrPut(host) { sortedSetOf() }
+        if (history.size == frequency - 1) {
+            ban(host)
+        } else {
+            history.add(Clock.System.now())
+        }
+    }
+
+    private fun ban(host: String) {
+        pending.remove(host)
+        banned[host] = Clock.System.now() + timeout
+        LOGGER.info("Banned (or extended existing ban for) $host")
+    }
+
+    private fun update() {
+        // updating the ban list
+        banned.entries.removeAll { it.value < Clock.System.now() }
+        // updating the pending state
+        val threshold = Clock.System.now() - period
+        pending.mapValues { it.value.prune(threshold = threshold) }
+    }
+
+    private fun SortedSet<Instant>.prune(threshold: Instant = Clock.System.now()): SortedSet<Instant> {
+        while (isNotEmpty() && first() < threshold) {
+            remove(first())
+        }
+        return this
+    }
+
+    private val ApplicationCall.host get() = request.origin.remoteAddress
+
+}
diff --git a/src/main/kotlin/services/auth/SessionManager.kt b/src/main/kotlin/services/auth/SessionManager.kt
new file mode 100644
index 0000000..5b8da9d
--- /dev/null
+++ b/src/main/kotlin/services/auth/SessionManager.kt
@@ -0,0 +1,52 @@
+package be.ugent.idlab.predict.ocmt.egress.services.auth
+
+import be.ugent.idlab.predict.ocmt.egress.services.resolve
+import io.ktor.util.logging.*
+import kotlinx.serialization.Serializable
+import java.util.*
+
+object SessionManager {
+
+    data object AlreadyExists: RuntimeException("Username already taken")
+    data object InvalidCredentials: RuntimeException("Invalid credentials")
+
+    @Serializable
+    data class Credentials(
+        val username: String,
+        val password: String
+    )
+
+    @Serializable
+    data class Token(
+        val token: String
+    )
+
+    private val LOGGER = KtorSimpleLogger("services.Auth")
+
+    private val properties = this::class.java
+        .classLoader
+        .getResourceAsStream("auth.properties")
+        .use { Properties().apply { load(it) } }
+
+    val secret = properties.resolve("jwt.secret")
+    val issuer = properties.resolve("jwt.issuer")
+    val audience = properties.resolve("jwt.audience")
+    val expiry = properties.resolve("jwt.expiry").toLong()
+
+    /**
+     * Creates a user account using the credentials found in the body
+     */
+    suspend fun createAccount(credentials: Credentials): Result<Unit> {
+        LOGGER.info("Incoming register attempt for `${credentials.username}`")
+        TODO("Pass the credentials to UserManager to create an account, returning a failure if no account has been created")
+    }
+
+    /**
+     * Creates a token result if the incoming call contains correct credentials, or a failure with matching exception
+     */
+    suspend fun processLogin(credentials: Credentials): Result<Token> {
+        LOGGER.info("Incoming login attempt for `${credentials.username}`")
+        TODO("Check the credentials using UserManager, only generating a token if valid")
+    }
+
+}
diff --git a/src/main/kotlin/services/auth/UserManager.kt b/src/main/kotlin/services/auth/UserManager.kt
new file mode 100644
index 0000000..081ed3e
--- /dev/null
+++ b/src/main/kotlin/services/auth/UserManager.kt
@@ -0,0 +1,85 @@
+package be.ugent.idlab.predict.ocmt.egress.services.auth
+
+import at.favre.lib.crypto.bcrypt.BCrypt
+import be.ugent.idlab.predict.ocmt.egress.services.resolve
+import kotlinx.coroutines.Dispatchers
+import org.jetbrains.exposed.sql.*
+import org.jetbrains.exposed.sql.transactions.experimental.newSuspendedTransaction
+import org.jetbrains.exposed.sql.transactions.transaction
+import java.util.*
+
+object UserManager {
+
+    object UserTable: Table() {
+
+        val username = varchar("username", 50)
+        val hash = binary("hash", 60)
+
+        override val primaryKey = PrimaryKey(username)
+
+    }
+
+    private val properties = this::class.java
+        .classLoader
+        .getResourceAsStream("auth.properties")
+        .use { Properties().apply { load(it) } }
+
+    private val database = Database.connect(
+        url = properties.resolve("mariadb.url"),
+        user = properties.resolve("mariadb.username"),
+        password = properties.resolve("mariadb.password"),
+        databaseConfig = DatabaseConfig(
+            body = {
+                defaultRepetitionAttempts = 1
+            }
+        )
+    )
+    private val hasher = BCrypt.withDefaults()
+    private val verifyer = BCrypt.verifyer()
+
+    init {
+        transaction(database) {
+            SchemaUtils.create(UserTable)
+        }
+    }
+
+    private suspend inline fun <T> db(noinline block: suspend Transaction.() -> T): T =
+        newSuspendedTransaction(context = Dispatchers.IO, db = database, statement = block)
+
+    /**
+     * Creates a user with the given `name` and `password`. This operation may fail, in which case `false` is returned.
+     * The most common cause for a failure is name collision (name already in use).
+     */
+    suspend fun create(name: String, password: String): Boolean {
+        return try {
+            db {
+                UserTable.insert {
+                    it[username] = name
+                    it[hash] = hasher.hash(12, password.toCharArray())
+                }
+            }
+            true
+        } catch (e: Exception) {
+            false
+        }
+    }
+
+    /**
+     * Checks the provided `name` and `password`, returning `true` if the credentials are correct.
+     */
+    suspend fun check(name: String, password: String): Boolean {
+        return try {
+            db {
+                UserTable
+                    .select(UserTable.hash)
+                    .where { UserTable.username eq name }
+                    .singleOrNull()
+                    ?.let { record -> verifyer.verify(password.toCharArray(), record[UserTable.hash]).verified }
+                    ?: false
+            }
+        } catch (e: Exception) {
+            false
+        }
+    }
+
+}
diff --git a/src/main/resources/application.yaml b/src/main/resources/application.yaml
index b1d7492..4e8d9ac 100644
--- a/src/main/resources/application.yaml
+++ b/src/main/resources/application.yaml
@@ -3,6 +3,7 @@ ktor:
     port: 8087
   application:
     modules:
+      - be.ugent.idlab.predict.ocmt.egress.server.modules.security.AuthKt.configure
       - be.ugent.idlab.predict.ocmt.egress.server.modules.BaseKt.setup
       - be.ugent.idlab.predict.ocmt.egress.server.modules.rest.ModuleKt.module
       - be.ugent.idlab.predict.ocmt.egress.server.modules.graphql.ModuleKt.module
diff --git a/src/main/resources/auth.properties b/src/main/resources/auth.properties
new file mode 100644
index 0000000..01cc139
--- /dev/null
+++ b/src/main/resources/auth.properties
@@ -0,0 +1,18 @@
+# JWT (session) configuration
+jwt.secret=${JWT_SECRET}
+jwt.issuer=0.0.0.0:8087
+jwt.audience=0.0.0.0:8087
+jwt.expiry=300000
+
+# Mariadb (user data) configuration
+mariadb.url=jdbc:mariadb://${MARIADB_URL}/${MARIADB_DATABASE}
+mariadb.username=${MARIADB_USERNAME}
+mariadb.password=${MARIADB_PASSWORD}
+
+# Rate limiting config
+# Duration of the timeout, in ms
+rl.timeout=60000
+# Period in which the number of bad calls are counted, in ms
+rl.period=20000
+# Number of calls required to mark a host as banned
+rl.frequency=3
\ No newline at end of file
diff --git a/src/main/resources/logback.xml b/src/main/resources/logback.xml
index 19ae741..cfa299b 100644
--- a/src/main/resources/logback.xml
+++ b/src/main/resources/logback.xml
@@ -8,4 +8,7 @@
         <appender-ref ref="STDOUT"/>
     </root>
     <logger name="io.netty" level="INFO"/>
+    <!-- Considering possible constraint exceptions are classified as warnings, they can be suppressed safely -->
+    <logger name="Exposed" level="ERROR" />
+    <logger name="org.mariadb.jdbc" level="ERROR" />
 </configuration>
\ No newline at end of file
